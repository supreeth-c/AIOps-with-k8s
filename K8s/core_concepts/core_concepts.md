## Core Concepts 
- Nodes 
  - Is a machine on which K8s is installed
  - Its can be  physical or virtual 
  - Node: 
      - Is a worker machine and that is where containers are launched by K8s
      - It was also called as Minions in the past
      - If the node on which the application is running fails, then obviously application goes down.
      - So we need more than one node
- Cluster: 
  - Its a set of nodes grouped together
  - This way even if a node fails, you have your applicaiton till accessible from other nodes 
  - Having multiple nodes helps in sharing the loads
  - Responsibility of a cluster: 
    - Managing the cluster
      - Information of the members of the cluster stored
      - How are nodes monitored ?
      - How do we move the workloads of the failed node to another worker node ?
      - MAster comes in here !
  - Master is another node, K8s installed in it and confiruged as a master 
  - it watches over the nodes in the clusters and responsbiole for the actual orchetration of the containers on the worker nodes.
- When K8s in installed on a system the following components are installed 
  - API server 
    - Acts as frontend for K8s, the users management devices, command line interfaces all talk to the API server to interact with k8s cluster
  - etcd 
    - Etcd is a distrubuted , reliable key value store used by k8s to store all data used to manage the cluster. 
    - Think of it this way when you have multiple nodes and multiple masters in your cluster, etcd stores all that information on all the nodes in the clsuter in a distrubuted manner.  
    - Etcd is responsbile for implementing locks within the cluster to ensure that there are no conflicts between the masters. 
  - Kubelet 
    - An agent running on each node in the cluster.
    - The agent is responsbile for making sure that the containers are running on the nodes as expected. 
  - container runtime 
    - Its underlying software that is used to run containers. In our case its docker but there are other options as well. 
  - controller 
    - They are the brain behind the orchestration
    - They are responsbile for noticing and responding  when nodes and containers or endpoints goes down. 
    - The controllers make decisions to bring up new containers in such cases. 
  - scheduler 
    - Its responsbile for distributing work or containers across multiple nodes.
    - It looks for newly created containers and assings them to nodes.
- How does on become master or slave 
  - Slave:
    - Places where containers are hosted and for docker cotnainers on a system, we need `container runtime` installed.
    - Thats where the container runtime falls. 
    - Worked node has kubelet agent, that is responsible for interacting with a master to provide health information of the worker node and carry out actions requested by the master on the worker nodes.
  - Master: 
    - Master server has Kube-apiserver  
  ![Master and Slave](master-slave.png)
- kubectl 
  - kube control is used to manage applications on a k8s cluster to get cluster infromation and status of other nodes
  - `kubectl run hello-minikube` is used to deploy an application 
  - `kubectl cluster-info` is used to view information about the cluster 
  - `kubectl get nodes` is used to get all the nodes part of the cluster

## Docker Vs ContainerD
- Docker & rocket  where the intial onces, but others wanted to get into k8s. 
- K8s introduced CRI `Container Runtime interface` allowed any work with it provided they supported `Open Container Initiative OCI` `https://github.com/opencontainers`
- OCI has `imagespec` and `runtimespec`
  - imagespec: : specifications on how an image should be built, It defines the specification
  - runtimespec: defines the stadards on how any container runtime should be developed 
- Rocker and other contaier runtime that adhered to OCI standards were now supported as a container runtimes for K8s via CRI
- Docker wasn't built to support CRI standards, because CRI came later 
- K8s introduced what is know as dockershim, which is a hackay but temporary way to continue support Docker outside of the CRI
- containerd can be used as a runtime of its own. 
- ![Docker vs ContainerD](dockervsContainerd.png)
- Because Docker followed the imagespec from OCI standards, so all the images built by Docker follows the standards. So they continue to work with containerd but Docker itself was removed as a supported runtime from K8s.
- ContainerD event though is part of Docker, is a sperate project on its own now, and is memeber of CNCF with graduated status. 
- One can install containerd without installing Docker itself.
- ![containerd](containerd.png)
- `nerdctl` provides a Docker like CLI for containerD it also supports Docker compose 
- `nerdctl` supports 
  - Encrypyted container image 
  - Lazy Pulling 
  - Namespaces in K8s
  - ![Nerdctl commands](nerdctl.png)
- `CRICTL` or `crictl`
  - To connect CRI compatabile container runtimes, the continerd and Rocker use `crictl` is a commandline utlity that is used to interact with CRI compatible container runtime.
  - ![crictl](crictl.png)
    - This managed by K8s and used to debug and installed seperately
    - kubectl doesn't know the containers so it will delete it. crictl utlity is only used for debugging purpose like getting inside a container
    - ![crictl commands](crictlcommand.png)
- Docker vs crictl 
  - ![alt text](compare.png)
  - ![alt text](containerdvsK8s.png)